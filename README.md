# 간단한 개요


unu는 '간결한 신택스로 난해한 언어 만들기'를 목표로 해서 만들어진 난해한 프로그래밍 언어로, 기본적으로 3개의 토큰('(', '1', ')'), 2개의 명령어(이항명령어, 사항명령어)로 이루어진 언어입니다.


unu라는 이름은 원래 에스페란토로 하나(1)를 뜻하는 단어로, 이 언어로 만들어진 코드를 가장 직관적으로 묘사하는 단어라고 생각해 언어 이름으로 사용하게 되었습니다.


unu 코드(아래 코드는 unu로 작성한 Hello, world! 프로그램입니다)는 기본적으로 다음과 같은 모습입니다:


```
(1,(((1,(1),(1),(1),1,(1),(1),1),(1,1,(1),1,(1),(1),1,1),(1,(1),
(1),1,1,(1),1,1),(1,(1),(1),1,1,(1),1,1),(1,1,1,1,1,(1),1,1),(1,
(1),(1),1,1,(1),1,(1)),(1,(1),(1),(1),(1),(1),1,(1)),(1,1,1,1,(1
),1,1,1),(1,1,1,1,1,(1),1,1),(1,(1),1,(1),(1),1,1,1),(1,(1),(1),
1,1,(1),1,1),(1,(1),(1),1,(1),(1),1,1),(1,1,(1),(1),(1),(1),1,(1
)),(1,(1),(1),(1),(1),(1),(1),(1))),(1,1),(((((1),1),(1,1,1)),1,
(((((((1,1,1),1,1),1,1),1,1),1,1),1,1),1,1),1),(((((1),(1,1,1)),
(((1),1),1)),(1,1,1)),1,1,1),(1,(1,1,1),((1),(1,(((1,1,1),1,1),1
,1),1))),((((1),1),1),(((1),1),1),((1,1,1),1,1),1),(((((1),(1,1,
1)),((((1),1),1),1,1)),(1,1,1)),(1,1,1),((1),(1,((1,1,1),1,1),1)
))),((((((1),(1,1,1)),(((1),1),1)),(1,1,1)),((((1),(1,1,1)),(((1
),1),1)),(1,1,1)),((1,1,1),((((1),(1,1,1)),(((1),1),1)),(1,1,1))
,1),1),(((((1),(1,1,1)),(((1),1),1)),(1,1,1)),((((1),(1,1,1)),((
(1),1),1)),(1,1,1)),((1,1,1),((((1),(1,1,1)),(((1),1),1)),(((1),
1),(1,1,1))),1),1),((((1),1),(1,1,1)),(((1),1),(1,1,1)),1,((1),(
1,(((1,1,1),1,1),1,1),1)))),(((((1),1),1),(((1),1),1),((1,1,1),1
,1),1),(((1,1,1)),((((1),(1,1,1)),((((1),1),1),1,1)),(1,1,1)),(1
,1,1),((1),(1,((((1,1,1),1,1),1,1),1,1),1))))),((((1),1),1),1,1,
1),(1,(1,1,1),((1),(1,((1,1,1),1,1),1))),((((1),1),1),1,1,1),(1,
(1,1,1),((1),(1,((((1,1,1),1,1),1,1),1,1),1))))
```


unu는 homoiconic한(=프로그램 코드와 프로그램이 다루는 데이터가 같은 형태를 띄는) 언어인 동시에, 데이터를 저장하는 영역을 따로 제공하지 않기 때문에 프로그램이 자기 자신의 일부 공간에 값을 읽고 쓰는 방식으로 데이터를 관리합니다.


이런 방식 때문에 unu에서는 코드와 데이터가 논리적으로 구분되지 않기 때문에 프로그래머에게 메모리 구조 위에 복잡하게 뒤섞인 코드와 데이터를 탐험하며 프로그램을 설계하는 도전할 만한 과제를 제공합니다.


# unu의 자료구조


unu는 유일한 자료구조로 '리스트'를 갖습니다. 리스트는 정수 혹은 다른 리스트를 아이템(리스트를 구성하는 각각의 요소)으로 갖는 배열로 기본적으로 그 크기에는 한계가 없습니다.


리스트의 예시:


```
(1, 1)

(1, (1, 1, 1), 1)

(1, ((1, 1), 1, 1), 1, 1)

등등등...
```


참고: 리스트 자체는 모든 정수를 저장할 수 있지만, 인터프리터가 인식하는 수가 1 하나 뿐이기 때문에 코드에서 사용할 수 있는 수는 1 뿐입니다.


참고: unu에서 유효한 토큰은 '(', '1', ')' 뿐입니다. 공백과 쉼표, 줄바꿈 등은 가독성을 위해 자유롭게 삽입될 수 있습니다.


리스트의 크기는 인터프리터가 코드를 해석할 때 정해진 이후 프로그램이 실행되는 내내 고정됩니다.


# unu의 메모리 구조


unu 프로그램이 사용할 수 있는 유일한 메모리 공간은 프로그램 코드 자기 자신입니다. unu 인터프리터는 코드를 읽어 리스트의 형태로 변환, 이 리스트의 아이템을 하나씩 명령어로 해석해 실행합니다.


예컨데 아래와 같은 코드는:

```
(1, 1, (1, 1, 1), (1, (1, 1), 1))
```


1, 1, (1, 1, 1), (1, (1, 1), 1)이라는 네 가지 아이템으로 나눠져 하나씩 명령어로 실행됩니다.

명령어 단위로 줄바꿈을 하여 가독성을 높이면 이런 모습이 됩니다:


```
(
    1,
    1,
    (1, 1, 1),
    (1, (1, 1), 1)
)
```


각각의 아이템을 명령어로 해석하는 방식은 다음과 같습니다:


* 아이템이 1, 2개인 리스트, '이항명령어' ([v, ]i):

레퍼런스 v를 받아 해당 리스트의 i번째 아이템의 레퍼런스를 반환합니다.

v는 생략될 수 있으며, 생략 시 기본값으로 프로그램 코드의 레퍼런스가 대입됩니다.


* 아이템이 3, 4개인 리스트, '사항명령어' ([d, ]a, b, s):

a의 정수 값(정수가 아닐 시 0)에서 b의 정수 값(정수가 아닐 시 0)을 뺀 값을 계산해 레퍼런스 d에 저장(가리키는 아이템이 정수가 아닐 시 무시) 및 반환하고, 만약 0보다 크다면 s의 값을 명령어의 리스트로 해석해 실행합니다. (알아 보실 분은 알아 보시겠지만, 기본적으로 subleq의 변형입니다.)

s값은 사용하는 것을 원치 않을 시 1을 채워넣을 수 있습니다. 1은 상수로 취급되므로 아무런 명령어도 실행하지 않습니다.

d는 생략될 수 있으며, 생략 시 기본값으로 프로그램 코드의 레퍼런스가 대입됩니다.


* 나머지 종류의 아이템:

상수로 해석됩니다. 기본적으로 명령어 자리에 왔을 때 무시됩니다.


명령어의 모든 매개인자는 상수를 만날 때까지 계속해서 또 다른 명령어의 반환값으로 해석됩니다.

예컨데 (((1, 1, 1)), ((1, 1, 1)), (1, 1, 1), 1)라는 명령어의 매개인자는 각각 ((1, 1, 1))과 ((1, 1, 1))과 (1, 1, 1)과 1이라는 또 다른 명령어로 해석되고, ((1, 1, 1))의 매개인자는 또 다시 (1, 1, 1)이라는 명령어로 해석됩니다.


# unu로 수 세기


unu로 수를 셀 때는 unu 내에서 유일하게 연산 기능을 가진 사항명령어가 유용하게 사용됩니다. 기본적으로 1과 뺄셈만으로 모든 수를 세는 방식입니다.

예컨데 0은 1-1, 2는 1-((1-1)-1), 3는 1-(((1-1)-1)-1)... 등으로 표현할 수 있습니다.

이를 삼항연산자로 옮기면 a-b를 (a, b, 1)로 옮길 수 있으므로 0 = (1, 1, 1), 2 = (1, ((1, 1, 1), 1, 1), 1), 3 = (1, (((1, 1, 1), 1, 1), 1, 1), 1) 등으로 표현할 수 있겠습니다.


# 입출력


unu의 입출력은 기본적으로 memory mapped io를 이용합니다. 인터프리터는 프로그램 코드의 0번째 아이템에 값을 읽고 쓸 때를 감지해서 콘솔 입출력을 실행합니다.

이는 대부분의 unu 코드가 첫번째 아이템을 1로 두는 이유이기도 합니다. 이 곳에 정수 값을 읽고 씀으로써 입출력을 수행해야 하기 때문입니다.


```
'''
(
    1, #p[0]. 이 곳에 입출력 데이터가 들어가야 합니다.
    #앞으로 프로그램 코드의 n번째 아이템을 p[n]으로 표기하겠습니다.
    (((1, 1, 1)), ((1, 1, 1)), 1, 1) # (p[0], p[0], 1, 1). 입력을 받은 후 1을 뺀 값을 출력합니다.
)
'''
```


unu는 p[0]의 값을 한 번 읽을 때마다 아스키 코드 값 하나를 읽어올 수 있으며, p[0]에 값을 한 번 쓸 때마다 아스키 코드 값 하나를 출력할 수 있습니다.


# 사항명령어의 s 매개인자 및 그를 활용한 서브루틴 구현:


사항명령어의 s 매개인자는 리스트를 받고 그를 프로그램으로 해석해 실행합니다.

이 때, s 매개인자는 unu 인터프리터가 또 다른 명령어로 해석해 리스트를 망가뜨리는 것을 막기 위해 1을 채워 넣어 상수로 해석되게끔 만들 수 있습니다.


```
...
(
    (1),
    (1, 1, 1),
    (
        (((1, 1, 1)), ((1, 1, 1)), (1, 1, 1), 1),
        (1, (1, 1, 1), ((1), ((1, 1, 1), (((1, 1, 1), 1, 1), 1, 1), 1))),
        1,
        1,
        1
    )
)
# 주의: 이 안에 있는 것들은 명령어들이 아닙니다. 이 코드 전체가 조금 긴 사항명령어입니다.
#사항명령어 (p, p[1], 0, 생략). p[1] - 0의 값이 0보다 크다면
#s매개인자의 값을 명령어 리스트로써 실행합니다.
...
```


만약 여러 번 사용되는 서브루틴을 만들고자 한다면, 프로그램 코드 중에 명령어 목록을 상수로 삽입하고, 해당 값을 사항명령어로 읽어들여 실행할 수 있습니다.

반복문 또한 비슷한 방법으로 만드는 것을 상상해 볼 수 있겠네요.


```
(
    1,
    (
        (((1, 1, 1)), ((1, 1, 1)), (1, 1, 1), 1),
        1,
        1,
        1,
        1
    ), #p[1]에 서브루틴을 상수로써 삽입합니다. 명령어로 해석되는 것을 막기 위해 덤프값 1을 삽입했습니다.

    ...

    (1, (1, 1, 1), (1)) #사항명령어 (1, 0, p[1]). p[1]의 값을 명령어 리스트로써 실행합니다.
    (1, (1, 1, 1), (1)) #이제 p[1]은 이 명령어를 호출할 때마다 실행됩니다.
)
```


# Hello, world! 프로그램


다음은 unu로 작성한 헬로 월드 프로그램 예시입니다.


```
(
    1, # p[0]. 입출력이 행해지는 곳이므로 1로 채워 둡시다.
    (
        (
            # p[1][0] = "Hello, world!"라는 문자열을 비트 단위로 저장했습니다.
            # 데이터는 1과 (1)로 이루어져 있는데, (1)은 정수가 아니기 때문에 사항명령어의
            # 인수로 전달할 시 명령어의 반환값이 0으로 변하는 것을 이용할 수 있습니다.
            # 이하 p[1][0]을 text로 서술하겠습니다.
            # text[n][1~7]이 비트로 나눠진 아스키 코드 값이며, text[n][0]은
            # 프로그램이 text[n][1~7]에 저장된 비트를 정수로 변환해 저장할 공간으로 사용될 것입니다.

            (1, (1), (1), (1), 1, (1), (1), 1), # H
            (1, 1, (1), 1, (1), (1), 1, 1), # e
            (1, (1), (1), 1, 1, (1), 1, 1), # l
            (1, (1), (1), 1, 1, (1), 1, 1), # l
            (1, 1, 1, 1, 1, (1), 1, 1), # o
            (1, (1), (1), 1, 1, (1), 1, (1)), # ,
            (1, (1), (1), (1), (1), (1), 1, (1)), #  
            (1, 1, 1, 1, (1), 1, 1, 1), # w
            (1, 1, 1, 1, 1, (1), 1, 1), # o
            (1, (1), 1, (1), (1), 1, 1, 1), # r
            (1, (1), (1), 1, 1, (1), 1, 1), # l
            (1, (1), (1), 1, (1), (1), 1, 1), # d
            (1, 1, (1), (1), (1), (1), 1, (1)), # !
            (1, (1), (1), (1), (1), (1), (1), (1))  # Null terminator
        ),
        (
            1, # p[1][1][0] 비트 변환 서브루틴에서 사용할 비트 인덱스 변수입니다.
            # 이하 bit로 서술하겠습니다.
            1  # p[1][1][1] 스트링 변환 서브루틴, 스트링 출력 서브루틴에서 사용할
            # 문자열 인덱스 변수입니다. 이하 index로 서술하겠습니다.
        ),
        (
            # p[1][2] = 스트링 변환 서브루틴.
            # 헬로 월드 문자열의 아이템을 하나씩 정수로 변환하고,
            # Null Terminator를 만날 때까지 반복하는 서브루틴입니다.

            # bit = 7
            ((((1), 1), (1, 1, 1)), 1, (((((((1, 1, 1), 1, 1), 1, 1), 1, 1), 1, 1), 1, 1), 1, 1), 1),
            # text[index][0] = 0
            (((((1), (1, 1, 1)), (((1), 1), 1)), (1, 1, 1)), 1, 1, 1),
            # 비트 변환 서브루틴 실행.
            (1, (1, 1, 1), ((1), (1, (((1, 1, 1), 1, 1), 1, 1), 1))),
            # index++
            ((((1), 1), 1), (((1), 1), 1), ((1, 1, 1), 1, 1), 1),
            # 만약 text[index - 1][0] > 0이라면 스트링 변환 서브루틴을 다시 한 번 실행합니다.
            (((((1), (1, 1, 1)), ((((1), 1), 1), 1, 1)), (1, 1, 1)), (1, 1, 1), ((1), (1, ((1, 1, 1), 1, 1), 1)))
        ),
        (
            # p[1][3] = 비트 변환 서브루틴
            # text[index][1~7]의 값을 하나씩 읽어 정수 값으로 변환, text[index][0]에 저장하는 서브루틴입니다.

            # text[index][0] *= 2
            (((((1), (1, 1, 1)), (((1), 1), 1)), (1, 1, 1)), ((((1), (1, 1, 1)), (((1), 1), 1)), (1, 1, 1)), ((1, 1, 1), ((((1), (1, 1, 1)), (((1), 1), 1)), (1, 1, 1)), 1), 1),
            # text[index][0] += text[index][bit]. 만약 text[index][bit]가 (1)일 시 0으로 처리되는 것을 이용한 트릭입니다.
            (((((1), (1, 1, 1)), (((1), 1), 1)), (1, 1, 1)), ((((1), (1, 1, 1)), (((1), 1), 1)), (1, 1, 1)), ((1, 1, 1), ((((1), (1, 1, 1)), (((1), 1), 1)), (((1), 1), (1, 1, 1))), 1), 1),
            # bit--, 만약 bit > 0이라면 스트링 변환 서브루틴을 다시 한 번 실행합니다.
            ((((1), 1), (1, 1, 1)), (((1), 1), (1, 1, 1)), 1, ((1), (1, (((1, 1, 1), 1, 1), 1, 1), 1)))
        ),
        (
            # p[1][4] = 스트링 출력 서브루틴
            # 변환된 헬로 월드 문자열을 하나씩 출력하고, Null Terminator를 만날 때까지 반복하는 서브루틴입니다.
            # index++
            ((((1), 1), 1), (((1), 1), 1), ((1, 1, 1), 1, 1), 1),
            # p[0] = text[index - 1][0]. 만약 값이 0보다 크다면 스트링 변환 서브루틴을 한 번 더 실행합니다.
            (((1, 1, 1)), ((((1), (1, 1, 1)), ((((1), 1), 1), 1, 1)), (1, 1, 1)), (1, 1, 1), ((1), (1, ((((1, 1, 1), 1, 1), 1, 1), 1, 1), 1)))
        )
    ),
    # index = 0
    ((((1), 1), 1), 1, 1, 1),
    # 스트링 변환 서브루틴을 실행합니다.
    (1, (1, 1, 1), ((1), (1, ((1, 1, 1), 1, 1), 1))),
    # index = 0
    ((((1), 1), 1), 1, 1, 1),
    # 스트링 출력 서브루틴을 실행합니다.
    (1, (1, 1, 1), ((1), (1, ((((1, 1, 1), 1, 1), 1, 1), 1, 1), 1)))
)
```
